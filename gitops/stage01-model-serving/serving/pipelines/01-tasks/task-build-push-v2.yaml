apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-and-push-v2
  namespace: private-ai-demo
  labels:
    app.kubernetes.io/name: modelcar-pipeline
spec:
  description: Build ModelCar image with Buildah (PVC-backed) and push to Quay

  params:
    - name: quay_org
      type: string
    - name: quay_repo
      type: string
    - name: quay_tag
      type: string
    - name: model_path
      type: string
      default: "models"

  workspaces:
    - name: source
    - name: quay-auth
      mountPath: /workspace/quay-auth

  results:
    - name: IMAGE_URL
    - name: IMAGE_DIGEST

  steps:
    - name: build-and-push
      image: registry.redhat.io/rhel9/buildah:latest
      # Use computeResources (not resources) - this is what Tekton actually accepts
      computeResources:
        requests:
          memory: "8Gi"
          cpu: "2"
        limits:
          memory: "16Gi"
          cpu: "4"
      # CRITICAL: Use PVC for ALL Buildah storage (matches original working task)
      env:
        - name: BUILDAH_STORAGE_ROOT
          value: $(workspaces.source.path)/.buildah-storage
        - name: STORAGE_DRIVER
          value: vfs
        - name: TMPDIR
          value: $(workspaces.source.path)/.tmp
        - name: HOME
          value: $(workspaces.source.path)/.home
      securityContext:
        capabilities:
          add:
            - SETFCAP
      script: |
        #!/bin/bash
        set -euo pipefail
        
        # Create all directories in workspace PVC (matches original working task)
        echo "ğŸ“ Setting up PVC-backed directories..."
        mkdir -p ${BUILDAH_STORAGE_ROOT}
        mkdir -p ${TMPDIR}
        mkdir -p ${HOME}
        
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ”¨ Build & Push to Quay [$(date -u +%Y-%m-%dT%H:%M:%SZ)]"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ¯ Configuration (matching original working task):"
        echo "  Storage Root: ${BUILDAH_STORAGE_ROOT} (PVC-backed)"
        echo "  Temp Dir:     ${TMPDIR} (PVC-backed)"
        echo "  Home Dir:     ${HOME} (PVC-backed)"
        echo "  Storage Driver: ${STORAGE_DRIVER}"
        echo "  Running as: $(id)"
        echo ""
        
        # CRITICAL: Disk usage BEFORE build
        echo "ğŸ“Š Storage BEFORE build:"
        df -h $(workspaces.source.path) /tmp /var/tmp 2>/dev/null || df -h $(workspaces.source.path)
        echo ""
        
        # Create Containerfile
        MODEL_PATH="$(params.model_path)"
        cat > $(workspaces.source.path)/Containerfile <<EOF
        FROM registry.access.redhat.com/ubi9/ubi-micro:9.5
        COPY ${MODEL_PATH} /models
        USER 1001
        CMD ["/bin/sh"]
        EOF
        
        IMAGE_LOCAL="localhost/$(params.quay_repo):$(params.quay_tag)"
        IMAGE_QUAY="quay.io/$(params.quay_org)/$(params.quay_repo):$(params.quay_tag)"
        
        echo "ğŸš€ Building: $IMAGE_QUAY"
        echo ""
        
        # Build image using --root flag (CRITICAL: tells buildah where to store everything)
        # Performance optimizations for large models (from original working task):
        #   --layers=false   : Skip intermediate layer commits (HUGE speedup for 48GB models!)
        #   --squash         : Single final layer (reduces image size)
        #   --ulimit nofile  : Increase file handle limit for parallel operations
        buildah --root ${BUILDAH_STORAGE_ROOT} --storage-driver=${STORAGE_DRIVER} bud \
          --format oci \
          --layers=false \
          --squash \
          --ulimit nofile=4096:8192 \
          --tag "${IMAGE_LOCAL}" \
          --file $(workspaces.source.path)/Containerfile \
          $(workspaces.source.path)
        
        echo "âœ… Build complete"
        echo ""
        
        # CRITICAL: Disk usage AFTER build
        echo "ğŸ“Š Storage AFTER build:"
        df -h $(workspaces.source.path) /tmp /var/tmp 2>/dev/null || df -h $(workspaces.source.path)
        echo ""
        
        echo "ğŸ“¤ Pushing to Quay..."
        echo ""
        
        # Push directly to Quay using --root flag
        # Note: Secret mounts as .dockerconfigjson (standard k8s format)
        buildah --root ${BUILDAH_STORAGE_ROOT} --storage-driver=${STORAGE_DRIVER} push \
          --authfile /workspace/quay-auth/.dockerconfigjson \
          --digestfile /tmp/image-digest \
          "${IMAGE_LOCAL}" \
          "docker://${IMAGE_QUAY}"
        
        echo "âœ… Push complete!"
        echo ""
        
        # Get digest from digestfile (more reliable than inspect)
        echo "ğŸ” Getting image digest..."
        if [ -f /tmp/image-digest ]; then
          DIGEST=$(cat /tmp/image-digest)
        else
          # Fallback to inspect if digestfile doesn't exist
          DIGEST=$(buildah --root ${BUILDAH_STORAGE_ROOT} --storage-driver=${STORAGE_DRIVER} inspect --format='{{.FromImageDigest}}' "${IMAGE_LOCAL}" 2>/dev/null || echo "sha256:unknown")
        fi
        
        echo "   Image:  $IMAGE_QUAY"
        echo "   Digest: $DIGEST"
        echo ""
        
        # Write metadata for downstream tasks (mirror-to-internal expects this filename)
        mkdir -p $(workspaces.source.path)/.pipeline-metadata
        cat > $(workspaces.source.path)/.pipeline-metadata/publish-metadata.json <<EOF
        {
          "image_quay": "${IMAGE_QUAY}",
          "digest": "${DIGEST}",
          "pushed_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        
        # Save results
        echo -n "$IMAGE_QUAY" > $(results.IMAGE_URL.path)
        echo -n "$DIGEST" > $(results.IMAGE_DIGEST.path)
        
        echo "âœ… Task complete: Model image built and pushed to Quay"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
