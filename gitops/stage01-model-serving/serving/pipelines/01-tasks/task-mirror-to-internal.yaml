apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: mirror-to-internal
  namespace: private-ai-demo
  labels:
    app.kubernetes.io/name: modelcar-pipeline
    app.kubernetes.io/component: task
  annotations:
    argocd.argoproj.io/sync-wave: "3"
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/tags: "modelcar,mirror,registry"
    tekton.dev/displayName: "Mirror Image to OpenShift Internal Registry"
spec:
  description: >-
    Mirrors the ModelCar image from Quay.io to OpenShift internal registry.
    
    This task runs in a NEW pod with a FRESH service account token, avoiding
    the 2-hour token expiry problem that plagued long-running build tasks.
    
    Uses registry-to-registry copy (skopeo) - NO local extraction needed,
    which prevents ephemeral storage blow-up for large images (80GB+).

  params:
    - name: namespace
      type: string
      description: Target namespace for internal registry
      default: "private-ai-demo"
    
    - name: image_stream_name
      type: string
      description: ImageStream name in OpenShift
    
    - name: image_tag
      type: string
      description: Tag for the ImageStream
      default: "latest"
    
    - name: internal_registry
      type: string
      description: OpenShift internal registry hostname
      default: "image-registry.openshift-image-registry.svc:5000"
    
    - name: tlsverify
      type: string
      description: Verify TLS for internal registry
      default: "false"

  workspaces:
    - name: source
      description: Shared workspace (contains publish-metadata.json from Task 1)
    - name: quay-auth
      description: Quay.io authentication secret (for source image)
      mountPath: /workspace/quay-auth
      readOnly: true

  results:
    - name: INTERNAL_IMAGE_URL
      description: Full internal registry image URL
    - name: MIRROR_STATUS
      description: Mirror operation status

  steps:
    - name: mirror-image
      image: quay.io/skopeo/stable:latest
      script: |
        #!/bin/bash
        set -e
        
        START_TIME=$(date +%s)
        
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ðŸ”„ Mirroring Image to OpenShift Internal Registry"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        # Read metadata from Task 1
        METADATA_FILE="$(workspaces.source.path)/.pipeline-metadata/publish-metadata.json"
        
        if [ ! -f "$METADATA_FILE" ]; then
          echo "âŒ ERROR: Metadata file not found: $METADATA_FILE"
          echo "   This task must run after build-and-push-to-quay"
          exit 1
        fi
        
        echo "ðŸ“‹ Reading publish metadata..."
        cat "$METADATA_FILE"
        echo ""
        
        # Extract source image URL from metadata
        SOURCE_IMAGE=$(cat "$METADATA_FILE" | grep -o '"image_quay": "[^"]*"' | cut -d'"' -f4)
        
        if [ -z "$SOURCE_IMAGE" ]; then
          echo "âŒ ERROR: Could not extract image_quay from metadata"
          exit 1
        fi
        
        # Construct destination image URL
        DEST_IMAGE="$(params.internal_registry)/$(params.namespace)/$(params.image_stream_name):$(params.image_tag)"
        
        echo "Source:      docker://$SOURCE_IMAGE"
        echo "Destination: docker://$DEST_IMAGE"
        echo "TLS Verify:  $(params.tlsverify)"
        echo ""
        
        # Login to internal registry with FRESH service account token
        echo "ðŸ” Authenticating to internal registry..."
        echo "   (Using fresh SA token from this pod - no expiry issue!)"
        
        # Get the service account token from the mounted secret
        SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
        
        # Create auth file for internal registry
        mkdir -p /tmp/auth
        cat > /tmp/auth/internal-auth.json << EOF
        {
          "auths": {
            "$(params.internal_registry)": {
              "auth": "$(echo -n "serviceaccount:${SA_TOKEN}" | base64 -w 0)"
            }
          }
        }
        EOF
        
        echo "âœ… Authentication configured"
        echo ""
        
        # Mirror image: Quay â†’ Internal Registry
        echo "ðŸš€ Starting registry-to-registry copy..."
        echo "   (No local extraction - network transfer only)"
        echo ""
        
        skopeo copy \
          --src-tls-verify=true \
          --dest-tls-verify=$(params.tlsverify) \
          --src-authfile /workspace/quay-auth/config.json \
          --dest-authfile /tmp/auth/internal-auth.json \
          "docker://$SOURCE_IMAGE" \
          "docker://$DEST_IMAGE"
        
        # Verify the mirror
        echo ""
        echo "ðŸ” Verifying mirrored image..."
        INTERNAL_DIGEST=$(skopeo inspect \
          --tls-verify=$(params.tlsverify) \
          --authfile /tmp/auth/internal-auth.json \
          "docker://$DEST_IMAGE" | grep -o '"Digest": "[^"]*"' | cut -d'"' -f4)
        
        # Calculate time
        END_TIME=$(date +%s)
        MIRROR_TIME=$((END_TIME - START_TIME))
        
        echo ""
        echo "âœ… Mirror Complete!"
        echo "   Internal URL: $DEST_IMAGE"
        echo "   Digest:       $INTERNAL_DIGEST"
        echo "   Time:         ${MIRROR_TIME}s ($(($MIRROR_TIME / 60))m $(($MIRROR_TIME % 60))s)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        # Update metadata with internal registry info
        echo ""
        echo "ðŸ“ Updating metadata with internal registry reference..."
        
        # Read existing metadata, add internal registry info
        cat "$METADATA_FILE" | sed '$s/}$/,/' > /tmp/metadata-updated.json
        cat >> /tmp/metadata-updated.json << EOF
          "image_internal": "${DEST_IMAGE}",
          "internal_digest": "${INTERNAL_DIGEST}",
          "mirrored_at_utc": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        }
        EOF
        
        # Write back to PVC
        cat /tmp/metadata-updated.json > "$METADATA_FILE"
        
        echo "âœ… Metadata updated:"
        cat "$METADATA_FILE"
        echo ""
        
        # Write results
        echo -n "$DEST_IMAGE" > $(results.INTERNAL_IMAGE_URL.path)
        echo -n "success" > $(results.MIRROR_STATUS.path)

