apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: rag-ingestion-simple
  namespace: private-ai-demo
spec:
  params:
    - name: input_uri
      type: string
      default: "s3://llama-files/sample/rag-mini.pdf"
    - name: docling_url
      type: string
      default: "http://docling.private-ai-demo.svc:8080"
    - name: milvus_uri
      type: string
      default: "tcp://milvus-standalone.private-ai-demo.svc.cluster.local:19530"
    - name: milvus_collection
      type: string
      default: "rag_documents_test"
    - name: min_entities
      type: string
      default: "5"
  
  workspaces:
    - name: shared-data
  
  tasks:
    - name: process-and-store
      workspaces:
        - name: data
          workspace: shared-data
      params:
        - name: input_uri
          value: $(params.input_uri)
        - name: docling_url
          value: $(params.docling_url)
        - name: milvus_uri
          value: $(params.milvus_uri)
        - name: milvus_collection
          value: $(params.milvus_collection)
        - name: min_entities
          value: $(params.min_entities)
      taskSpec:
        params:
          - name: input_uri
          - name: docling_url
          - name: milvus_uri
          - name: milvus_collection
          - name: min_entities
        workspaces:
          - name: data
        steps:
          - name: download-and-process
            image: registry.access.redhat.com/ubi9/python-311:latest
            script: |
              #!/bin/bash
              set -e
              
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "STEP 1: Download document from MinIO"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              
              pip install --quiet boto3 requests pymilvus sentence-transformers
              
              python3 << 'PYEOF'
              import os
              import boto3
              from botocore.client import Config
              import requests
              import json
              from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType, utility
              from sentence_transformers import SentenceTransformer
              
              # Configuration
              input_uri = "$(params.input_uri)"
              docling_url = "$(params.docling_url)"
              milvus_uri = "$(params.milvus_uri)"
              collection_name = "$(params.milvus_collection)"
              min_entities = int("$(params.min_entities)")
              
              # MinIO credentials from environment (will be set via secret)
              minio_endpoint = "minio.model-storage.svc:9000"
              access_key = os.environ.get("AWS_ACCESS_KEY_ID", "admin")
              secret_key = os.environ.get("AWS_SECRET_ACCESS_KEY", "minioadmin")
              
              print(f"\nğŸ“¥ Downloading from: {input_uri}")
              
              # Parse S3 URI
              if input_uri.startswith("s3://"):
                  input_uri = input_uri[5:]
              parts = input_uri.split("/", 1)
              bucket = parts[0]
              key = parts[1]
              
              # Download from MinIO
              s3_client = boto3.client(
                  "s3",
                  endpoint_url=f"http://{minio_endpoint}",
                  aws_access_key_id=access_key,
                  aws_secret_access_key=secret_key,
                  config=Config(signature_version="s3v4"),
                  region_name="us-east-1"
              )
              
              doc_path = "/tmp/document.pdf"
              s3_client.download_file(bucket, key, doc_path)
              print(f"âœ… Downloaded to: {doc_path}")
              
              print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              print("STEP 2: Process with Docling")
              print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              
              with open(doc_path, "rb") as f:
                  files = {"file": ("document.pdf", f, "application/pdf")}
                  response = requests.post(
                      f"{docling_url}/convert?format=markdown",
                      files=files,
                      timeout=300
                  )
                  response.raise_for_status()
              
              result = response.json()
              markdown = result.get("content", "")
              print(f"âœ… Extracted {len(markdown)} characters")
              
              print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              print("STEP 3: Generate embeddings")
              print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              
              # Simple chunking
              chunks = [c.strip() for c in markdown.split("\n\n") if c.strip() and len(c.strip()) > 20]
              print(f"Created {len(chunks)} chunks")
              
              # Load embedding model
              print("Loading sentence-transformers model...")
              model = SentenceTransformer('all-MiniLM-L6-v2')  # Small, fast model
              
              # Generate embeddings
              embeddings = model.encode(chunks)
              print(f"âœ… Generated {len(embeddings)} embeddings (dim={embeddings.shape[1]})")
              
              print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              print("STEP 4: Store in Milvus")
              print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              
              # Connect to Milvus
              print(f"Connecting to: {milvus_uri}")
              connections.connect(uri=milvus_uri, timeout=30)
              
              # Create collection if needed
              if not utility.has_collection(collection_name):
                  print(f"Creating collection: {collection_name}")
                  fields = [
                      FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
                      FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=65535),
                      FieldSchema(name="source", dtype=DataType.VARCHAR, max_length=512),
                      FieldSchema(name="chunk_id", dtype=DataType.INT64),
                      FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=embeddings.shape[1])
                  ]
                  schema = CollectionSchema(fields, description="RAG test collection")
                  collection = Collection(name=collection_name, schema=schema)
                  
                  # Create index
                  index_params = {"metric_type": "L2", "index_type": "IVF_FLAT", "params": {"nlist": 128}}
                  collection.create_index("embedding", index_params)
              else:
                  collection = Collection(collection_name)
              
              # Insert data
              texts = chunks
              sources = [f"s3://{bucket}/{key}"] * len(chunks)
              chunk_ids = list(range(len(chunks)))
              embedding_list = embeddings.tolist()
              
              collection.insert([texts, sources, chunk_ids, embedding_list])
              collection.flush()
              
              num_entities = collection.num_entities
              print(f"âœ… Inserted {len(chunks)} chunks")
              print(f"   Total entities in collection: {num_entities}")
              
              print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              print("STEP 5: Verify ingestion")
              print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              
              success = num_entities >= min_entities
              if success:
                  print(f"âœ… VERIFICATION PASSED: {num_entities} >= {min_entities}")
              else:
                  print(f"âŒ VERIFICATION FAILED: {num_entities} < {min_entities}")
                  exit(1)
              
              # Test query
              print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              print("STEP 6: Test query")
              print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              
              collection.load()
              query_text = "What is the purpose of this document?"
              query_embedding = model.encode([query_text])[0].tolist()
              
              results = collection.search(
                  data=[query_embedding],
                  anns_field="embedding",
                  param={"metric_type": "L2", "params": {"nprobe": 10}},
                  limit=3,
                  output_fields=["text", "source"]
              )
              
              print(f"\nQuery: {query_text}")
              print(f"\nTop 3 results:")
              for i, hit in enumerate(results[0]):
                  print(f"\n{i+1}. Distance: {hit.distance:.4f}")
                  print(f"   Text: {hit.entity.get('text')[:200]}...")
              
              print("\nâœ… Pipeline completed successfully!")
              PYEOF
            env:
              - name: AWS_ACCESS_KEY_ID
                valueFrom:
                  secretKeyRef:
                    name: minio-credentials
                    key: accesskey
                    optional: false
              - name: AWS_SECRET_ACCESS_KEY
                valueFrom:
                  secretKeyRef:
                    name: minio-credentials
                    key: secretkey
                    optional: false
