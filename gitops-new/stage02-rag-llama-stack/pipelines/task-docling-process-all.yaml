---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: docling-process-all
  namespace: private-ai-demo
  labels:
    app: docling-rag-pipeline
    component: docling-processing
spec:
  description: |
    Process all PDF documents in a scenario directory using the Docling API.
    Calls the real Docling service endpoint for document conversion.
  
  params:
    - name: scenario
      type: string
      description: "Scenario name"
    
    - name: docling-url
      type: string
      description: "Docling service URL"
      default: "http://shared-docling-service.ai-infrastructure.svc:5001"
  
  workspaces:
    - name: documents
      description: "Workspace with PDFs and output"
      mountPath: /workspace/documents
  
  steps:
    - name: process-all-pdfs
      image: python:3.11-slim
      env:
        - name: PYTHONUNBUFFERED
          value: "1"
      script: |
        #!/usr/bin/env python3
        import os
        import json
        import time
        import urllib.request
        import urllib.error
        from pathlib import Path
        
        print("=" * 60)
        print("  Docling PDF Processing (Production)")
        print("=" * 60)
        print()
        
        scenario = "$(params.scenario)"
        docling_url = "$(params.docling-url)"
        
        input_dir = Path(f"/workspace/documents/scenario2-{scenario}")
        output_dir = Path(f"/workspace/documents/processed/scenario2-{scenario}")
        output_dir.mkdir(parents=True, exist_ok=True)
        
        print(f"Scenario: {scenario}")
        print(f"Docling URL: {docling_url}")
        print(f"Input: {input_dir}")
        print(f"Output: {output_dir}")
        print()
        
        def call_docling_api(pdf_path):
            """Call Docling API to process a PDF"""
            # Read PDF file
            with open(pdf_path, 'rb') as f:
                pdf_data = f.read()
            
            # Create multipart form data
            boundary = '----WebKitFormBoundary' + ''.join(str(i) for i in range(16))
            
            body_parts = []
            body_parts.append(f'--{boundary}'.encode())
            body_parts.append(f'Content-Disposition: form-data; name="files"; filename="{pdf_path.name}"'.encode())
            body_parts.append(b'Content-Type: application/pdf')
            body_parts.append(b'')
            body_parts.append(pdf_data)
            body_parts.append(f'--{boundary}--'.encode())
            body_parts.append(b'')
            
            body = b'\r\n'.join(body_parts)
            
            # Make async request
            req = urllib.request.Request(
                f"{docling_url}/v1/convert/file/async",
                data=body,
                headers={
                    'Content-Type': f'multipart/form-data; boundary={boundary}',
                    'Content-Length': str(len(body))
                }
            )
            
            try:
                with urllib.request.urlopen(req, timeout=60) as response:
                    result = json.loads(response.read().decode('utf-8'))
                    return result
            except urllib.error.HTTPError as e:
                error_body = e.read().decode('utf-8')
                print(f"‚ùå HTTP Error {e.code}: {error_body}")
                raise
            except Exception as e:
                print(f"‚ùå Error: {e}")
                raise
        
        def poll_docling_result(task_id):
            """Poll Docling for task completion"""
            max_attempts = 60  # 5 minutes
            
            for attempt in range(max_attempts):
                req = urllib.request.Request(
                    f"{docling_url}/v1/convert/file/result/{task_id}"
                )
                
                try:
                    with urllib.request.urlopen(req, timeout=10) as response:
                        result = json.loads(response.read().decode('utf-8'))
                        status = result.get('status', 'unknown')
                        
                        if status == 'completed':
                            return result
                        elif status == 'failed':
                            raise Exception(f"Docling processing failed: {result.get('error')}")
                        
                        # Still processing
                        if attempt % 5 == 0:
                            print(f"  Status: {status} (attempt {attempt+1}/{max_attempts})")
                        
                        time.sleep(5)
                
                except urllib.error.HTTPError as e:
                    if e.code == 404:
                        # Task not found yet, wait
                        time.sleep(5)
                    else:
                        raise
            
            raise Exception(f"Timeout waiting for task {task_id}")
        
        # Process all PDFs
        pdf_files = list(input_dir.glob("*.pdf"))
        print(f"üìÅ Found {len(pdf_files)} PDF files")
        print()
        
        total_processed = 0
        total_failed = 0
        
        for pdf_file in pdf_files:
            basename = pdf_file.stem
            print(f"üìÑ Processing: {pdf_file.name}")
            print(f"   Size: {pdf_file.stat().st_size / (1024*1024):.1f} MB")
            
            try:
                # Submit to Docling
                print("   üöÄ Submitting to Docling...")
                submit_result = call_docling_api(pdf_file)
                task_id = submit_result.get('task_id')
                
                if not task_id:
                    print(f"   ‚ùå No task_id in response: {submit_result}")
                    total_failed += 1
                    continue
                
                print(f"   ‚úÖ Task ID: {task_id}")
                
                # Poll for result
                print("   ‚è≥ Waiting for processing...")
                result = poll_docling_result(task_id)
                
                # Extract markdown content
                markdown_content = result.get('markdown', '')
                if not markdown_content:
                    # Try alternate fields
                    markdown_content = result.get('content', result.get('text', ''))
                
                if markdown_content:
                    # Save markdown
                    md_file = output_dir / f"{basename}.md"
                    with open(md_file, 'w', encoding='utf-8') as f:
                        f.write(markdown_content)
                    
                    # Save full response
                    response_file = output_dir / f"{basename}-response.json"
                    with open(response_file, 'w', encoding='utf-8') as f:
                        json.dump(result, f, indent=2)
                    
                    print(f"   ‚úÖ Saved: {md_file.name}")
                    print(f"   üíæ Response: {response_file.name}")
                    total_processed += 1
                else:
                    print(f"   ‚ö†Ô∏è  No content in result")
                    total_failed += 1
                
            except Exception as e:
                print(f"   ‚ùå Error: {e}")
                total_failed += 1
            
            print()
        
        print(f"‚úÖ Processing complete!")
        print(f"   Processed: {total_processed}")
        print(f"   Failed: {total_failed}")
        
        if total_processed == 0:
            raise Exception("No documents processed successfully")
        
        # Write result
        with open("$(results.count.path)", 'w') as f:
            f.write(str(total_processed))
  
  results:
    - name: count
      description: "Number of documents processed"

